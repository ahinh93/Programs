To begin, the program needs to be executed just like any other program in the terminal, mine is  ./osh. Once that's executed, my mini Shell takes over and starts waiting for user input. Rather than putting everything into the main(), I've broken up the responsibilities of the mini shell into three main parts. I also create an array here called args that will hold the users inputs for each call and will be passed to each of the helper methods.

The first part is fetchInstruct(). Since my main doesn't take any parameters (which it shouldn't), the fetchInstruct needs to take user input after the call to run shell is made. I allocate a char pointer that will hold the user input. I use fgets() instead of scanf because scanf naturally has a space character delimiter that tokenizes. fgets gives me the whole line from the keyboard up to 256 bytes and puts it into my char pointer. I manually remove the carriage return at the end because fgets also picks that up from keyboard and puts it as part of the user input. I tokenize the user input by spaces and set each into an index of the array. Every single time an index gets added with a parameter, I increase counters that I've made to help keep track. If the last non-empty index of the input array is &, then remove that from the array and replace with NULL. Then raise the background request flag.  

The second part is runInstruct() which takes the now populated user-argument array. I call pid_t pid = fork(), where pid is now the identifier on whether the current process is either a child or parent process depending on what fork() returns. Since fork() was called, a child process was also created. Now, if fork() returned less than 0, an error occurred. If fork was greater than 0, then the current process executing is the parent and will check if a background process request was made. If so, then wait() is called until the child is finished running. If not, then don't call wait(). If the process is a child, then fork() will return 0. The child will also first check whether a background process was made or not before doing anything. If it was, then it will print out its pid along with the name of the program and repeat the list user inputs. Now, the child will execvp the argument array regardless of whether its background or not.

Finally, I made a method call clean() which just resets any counters I used in my method when trying to execute a given user input.
