Jesse Alltop

	Going over this program in class, made it seem pretty straight forward. However, just like with any other assignment there were aspects that slowed me down while developing this program. For example, I originally had tried to implement the buffer object into its own cpp file, but I moved the methods to my driver file and it allowed me to use them like i assumed that I could have. I am sure that there is a method for using class methods with threads, but for the scope of this assignment and class I decided to move them and it seemed to work out well for me. I also ran into another issue where I was grabbing the mutex lock before my semaphore, which cause the first consumer to grab the lock and never release that lock, thus a producer could never write to the buffer and since there was nothing in the buffer, there was nothing for the consumer to consume. Then, I had another issue with the semaphores. This issue was created because in my consumer I would grab the full semaphore, and then release it when before the end of the thread. However, I needed to release the empty semaphore, similarly there was an issue within the producer threads of grabbing the empty semaphore and then releasing it. Going over the notes from class made me recognize what I was doing wrong and once corrected it solved the problem of no producers be allowed to fill the buffer, which of course led to none of the consumers having anything to read. Given more time I would be very interested to see how multithreading would work with objects and member methods of those objects. I think that it would convenient to have, you could perhaps spilt apart methods, that wouldn't need to access the same data within the object, and run them as threads to give you higher performance, but going over what we have discussed in class and the book I haven't found an obvious answer to this question.    
